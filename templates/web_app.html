<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surasura - Reading List</title>
    <style>
        :root {
            --primary: #6200ee;
            --primary-variant: #3700b3;
            --secondary: #03dac6;
            --background: #121212;
            --surface: #1e1e1e;
            --error: #cf6679;
            --on-primary: #ffffff;
            --on-background: #ffffff;
            --on-surface: #ffffff;
            --text-secondary: #b0b0b0;
            --card-border: #333;
            --header-height: 60px;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background);
            color: var(--on-background);
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* --- Loading Screen --- */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: var(--primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* --- Header & Tabs --- */
        header {
            background-color: var(--surface);
            padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            height: 60px;
            flex-shrink: 0;
        }

        h1 {
            font-size: 1.2rem;
            font-weight: 500;
            margin-right: 40px;
        }

        .main-tabs {
            display: flex;
            height: 100%;
        }

        .main-tab-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1rem;
            padding: 0 20px;
            cursor: pointer;
            height: 100%;
            transition: color 0.2s, border-bottom 0.2s;
            border-bottom: 3px solid transparent;
            font-weight: 500;
        }

        .main-tab-btn:hover {
            color: var(--on-surface);
        }

        .main-tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        /* --- Main Content Area --- */
        #content-area {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .view {
            display: none;
            flex: 1;
            overflow: hidden;
            flex-direction: column;
            /* Flex column so the inner parts can scroll correctly */
        }

        .view.active {
            display: flex;
        }

        /* --- Progressive View Layout --- */
        /* Takes up full height of view. Has Sidebar + Main List */
        .progressive-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .file-sidebar {
            width: 250px;
            background-color: #181818;
            border-right: 1px solid var(--card-border);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .file-tab {
            padding: 15px 20px;
            cursor: pointer;
            color: var(--text-secondary);
            border-left: 3px solid transparent;
            transition: background 0.2s;
            font-size: 0.9rem;
            word-break: break-all;
        }

        .file-tab:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .file-tab.active {
            background-color: rgba(98, 0, 238, 0.1);
            color: var(--primary);
            border-left-color: var(--primary);
        }

        .word-list-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        /* --- Cards --- */
        .card {
            background-color: var(--surface);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--card-border);
            transition: transform 0.2s;
            content-visibility: auto;
            contain-intrinsic-size: 1px 200px;
            /* Estimate height to prevent scrollbar jumping */
        }

        .card.ignored {
            opacity: 0.5;
            filter: grayscale(100%);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .word-main {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--secondary);
            margin-right: 10px;
        }

        .reading {
            font-size: 1rem;
            color: var(--text-secondary);
            user-select: none;
            pointer-events: none;
            display: inline-block;
            margin-right: 5px;
        }

        .reading::after {
            content: attr(data-reading);
        }

        /* --- Priority Markers --- */
        .priority-marker {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            vertical-align: middle;
            cursor: help;
        }

        .marker-priority::before {
            content: "✦";
            color: #FFD700;
            text-shadow: 0 0 3px rgba(255, 215, 0, 0.4);
        }

        .marker-lopsided::before {
            content: "⚖";
            color: #03dac6;
            text-shadow: 0 0 3px rgba(3, 218, 198, 0.4);
        }

        /* Zen Mode Specific Subtlety (Lowkey / Grayscale) */
        body.theme-zen-focus .priority-marker {
            filter: grayscale(100%) opacity(0.4);
            font-size: 1.1rem;
            margin-left: 18px;
        }

        .tier-badge {
            background-color: #333;
            color: #ddd;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            white-space: nowrap;
        }

        .tier-badge.tier-1 {
            background-color: #b71c1c;
            color: white;
        }

        .tier-badge.tier-2 {
            background-color: #f57f17;
            color: black;
        }

        .tier-badge.tier-3 {
            background-color: #1b5e20;
            color: white;
        }

        .tier-badge.tier-4 {
            background-color: #0277bd;
            color: white;
        }

        .tier-badge.tier-5 {
            background-color: #4a148c;
            color: white;
        }

        .tier-badge.tier-outside {
            background-color: #616161;
            color: #ddd;
        }

        .context-box {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 12px;
            border-radius: 4px;
            margin: 12px 0;
            font-size: 1.1rem;
            line-height: 1.6;
            color: #eee;
        }

        .context-box em {
            color: var(--secondary);
            font-style: normal;
            font-weight: bold;
            text-decoration: underline;
        }

        .card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .stats span {
            margin-right: 15px;
        }

        .actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            background: transparent;
            border: 1px solid var(--text-secondary);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn:hover {
            border-color: var(--on-surface);
            color: var(--on-surface);
        }

        .btn-ignore:hover {
            border-color: var(--error);
            color: var(--error);
        }

        /* --- Sources Toggle --- */
        .sources-section {
            margin-top: 10px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }

        .sources-toggle {
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.85rem;
            user-select: none;
        }

        .sources-list {
            margin-top: 8px;
            font-size: 0.85rem;
            color: #888;
            display: none;
        }

        .sources-list.visible {
            display: block;
        }

        /* --- Extra Contexts --- */
        .extra-contexts {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed #444;
        }

        .extra-contexts.visible {
            display: block;
        }

        .context-item {
            margin-bottom: 8px;
            font-size: 0.95rem;
            color: #ccc;
            padding-left: 10px;
            border-left: 2px solid var(--primary);
        }

        .toggle-contexts-btn {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            background: rgba(255, 255, 255, 0.03);
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1rem;
            padding: 4px 0;
            transition: background 0.2s, color 0.2s;
            border-radius: 4px;
            margin-top: -8px;
            /* Pull closer to context box */
            margin-bottom: 4px;
        }

        .toggle-contexts-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--primary);
        }

        .toggle-contexts-btn .arrow {
            transition: transform 0.3s;
            font-size: 0.8rem;
            opacity: 0.6;
        }

        .toggle-contexts-btn.active .arrow {
            transform: rotate(180deg);
        }

        /* --- Comprehension Bar --- */
        .comprehension-stats {
            background: var(--surface);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95rem;
        }

        .progress-container {
            height: 12px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            display: flex;
        }

        .progress-segment {
            height: 100%;
            transition: width 0.5s ease-out;
        }

        .segment-base {
            background: #4caf50;
            opacity: 0.3;
        }

        .segment-start {
            background: #4caf50;
            opacity: 0.6;
        }

        .segment-target {
            background: #4caf50;
        }

        .legend {
            display: flex;
            gap: 15px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        /* --- THEME: Zen Focus --- */
        body.theme-zen-focus {
            --background: #000000;
            --surface: #0a0a0a;
            --card-border: #1a1a1a;
            --primary: #ffffff;
            --secondary: #aaaaaa;
            --text-primary: #dddddd;
            --text-secondary: #666666;
            background-color: var(--background);
            color: var(--text-primary);
            font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, monospace;
            overflow-y: auto !important;
            height: auto !important;
            display: block !important;
        }

        body.theme-zen-focus #content-area,
        body.theme-zen-focus .view,
        body.theme-zen-focus .progressive-container,
        body.theme-zen-focus .word-list-container {
            overflow: visible !important;
            height: auto !important;
            flex: none !important;
            display: block !important;
        }

        body.theme-zen-focus .word-list-container {
            max-width: 700px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        body.theme-zen-focus header {
            position: sticky;
            top: 0;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.9);
            border-bottom: 1px solid var(--card-border);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
        }

        body.theme-zen-focus header h1 {
            margin: 0;
            padding: 10px 0;
            font-size: 1.2rem;
            opacity: 0.5;
        }

        body.theme-zen-focus * {
            box-shadow: none !important;
            transition: none !important;
            animation: none !important;
            backdrop-filter: none !important;
        }



        body.theme-zen-focus .card {
            background-color: transparent;
            border: 1px solid var(--card-border);
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 10px;
        }

        body.theme-zen-focus .word-main {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--primary);
        }

        body.theme-zen-focus .reading {
            color: var(--secondary);
            font-size: 1.2rem;
            margin-left: 12px;
        }

        body.theme-zen-focus .context-box {
            background: transparent;
            border: none;
            border-left: 1px solid var(--text-secondary);
            padding-left: 10px;
            font-size: 1.2rem;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        body.theme-zen-focus .context-item-zen {
            line-height: 1.5;
        }



        body.theme-zen-focus .context-box em {
            color: var(--primary);
            font-weight: bold;
            text-decoration: underline;
        }

        body.theme-zen-focus .file-sidebar {
            background-color: var(--background);
            border-right: 1px solid var(--card-border);
        }

        body.theme-zen-focus .file-tab {
            border: none;
            padding: 8px 15px;
            font-size: 0.85rem;
        }

        body.theme-zen-focus .file-tab.active {
            background-color: var(--card-border);
            color: var(--primary);
        }

        body.theme-zen-focus .comprehension-stats {
            background-color: var(--background);
            border: 1px solid var(--card-border);
            padding: 10px;
            font-size: 0.8rem;
        }

        body.theme-zen-focus .progress-container {
            height: 4px;
            background: #111;
        }

        body.theme-zen-focus .progress-segment.segment-base {
            background: #333;
        }

        body.theme-zen-focus .progress-segment.segment-start {
            background: #666;
        }

        body.theme-zen-focus .progress-segment.segment-target {
            background: #999;
        }

        body.theme-zen-focus .btn-ignore {
            background: transparent;
            border: 1px solid var(--card-border);
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        body.theme-zen-focus .btn-ignore:hover {
            border-color: #ff0000;
            color: #ff0000;
        }

        /* --- THEME: Midnight (Vibrant) --- */
        body.theme-midnight-vibrant {
            --background: #0d0c1d;
            --surface: #1b1a37;
            --card-border: rgba(255, 255, 255, 0.05);
            --primary: #ff5f6d;
            --secondary: #ffc371;
            --accent-purple: #6c5ce7;
            --text-primary: #ffffff;
            --text-secondary: #b2bec3;
            --gradient: linear-gradient(90deg, #ff5f6d 0%, #ffc371 100%);
            font-family: 'Inter', 'Segoe UI', sans-serif;
        }

        body.theme-midnight-vibrant header {
            background-color: var(--surface);
            border-bottom: 2px solid var(--accent-purple);
        }

        body.theme-midnight-vibrant .card {
            background-color: var(--surface);
            border-radius: 20px;
            padding: 24px;
            margin-bottom: 16px;
            border: 1px solid var(--card-border);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        body.theme-midnight-vibrant .word-main {
            font-size: 2.2rem;
            font-weight: 700;
            background: var(--gradient);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            display: inline-block;
        }

        body.theme-midnight-vibrant .main-tab-btn.active {
            background: var(--gradient) !important;
            border: none;
            border-radius: 12px;
            color: white;
            font-weight: 600;
        }

        body.theme-midnight-vibrant .tier-badge {
            background: var(--accent-purple);
            border-radius: 8px;
            color: white;
        }

        body.theme-midnight-vibrant .context-box em {
            color: var(--secondary);
            font-weight: bold;
        }

        /* --- THEME: World Class (Flow) --- */
        body.theme-world-class {
            --background: #0a0a0a;
            --surface: #141414;
            --card-border: #222;
            --primary: #bb86fc;
            --secondary: #03dac6;
            --text-secondary: #888;
            font-family: 'Inter', 'Segoe UI', sans-serif;
            /* Cleaner font stack */
        }

        body.theme-world-class header {
            background-color: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: none;
        }

        body.theme-world-class .card {
            background-color: transparent;
            /* Simplicity */
            border: none;
            border-bottom: 1px solid var(--card-border);
            border-radius: 0;
            padding: 25px 0;
            /* More breathing room */
            margin-bottom: 0;
            box-shadow: none;
        }

        body.theme-world-class .card-header {
            margin-bottom: 12px;
        }

        body.theme-world-class .word-main {
            font-size: 2rem;
            /* Larger focus */
            font-weight: 300;
            /* Lighter weight for elegance */
            color: #fff;
            letter-spacing: 0.05em;
        }

        body.theme-world-class .reading {
            font-size: 1.1rem;
            color: var(--primary);
            opacity: 0.8;
            font-weight: 400;
        }

        body.theme-world-class .context-box {
            background: transparent;
            padding: 0;
            font-size: 1.25rem;
            /* Larger reading text */
            line-height: 1.8;
            /* Better flow */
            color: #ccc;
            border-left: 2px solid var(--secondary);
            padding-left: 15px;
        }

        body.theme-world-class .context-box em {
            color: var(--secondary);
            font-weight: 600;
            text-decoration: none;
            border-bottom: 1px solid rgba(3, 218, 198, 0.3);
        }

        body.theme-world-class .tier-badge {
            background: transparent;
            border: 1px solid #333;
            font-weight: normal;
            font-size: 0.7rem;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        body.theme-world-class .file-sidebar {
            background-color: #050505;
            border-right: 1px solid #111;
        }

        body.theme-world-class .file-tab {
            border-left: none;
            border-right: 2px solid transparent;
            opacity: 0.6;
        }

        body.theme-world-class .file-tab.active {
            background-color: transparent;
            border-color: var(--primary);
            color: #fff;
            opacity: 1;
        }

        /* --- THEME: Modern Light --- */
        body.theme-modern-light {
            --background: #f8f9fa;
            --surface: #ffffff;
            --card-border: #e9ecef;
            --primary: #6c5ce7;
            --secondary: #00cec9;
            --on-background: #2d3436;
            --on-surface: #2d3436;
            --text-secondary: #636e72;
            background-color: var(--background);
            color: var(--on-background);
        }

        body.theme-modern-light header {
            background-color: var(--surface);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            border-bottom: 1px solid var(--card-border);
        }

        body.theme-modern-light .card {
            background-color: var(--surface);
            border-radius: 12px;
            border: 1px solid var(--card-border);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.02);
            padding: 24px;
            margin-bottom: 20px;
        }

        body.theme-modern-light .word-main {
            color: var(--on-surface);
            font-weight: 700;
        }

        body.theme-modern-light .reading {
            color: var(--primary);
        }

        body.theme-modern-light .context-box {
            background-color: #f1f2f6;
            border-left: 4px solid var(--primary);
            color: #2d3436;
        }

        body.theme-modern-light .context-box em {
            color: var(--primary);
            background-color: rgba(108, 92, 231, 0.1);
            padding: 0 2px;
            border-radius: 3px;
        }

        body.theme-modern-light .file-sidebar {
            background-color: var(--surface);
            border-right: 1px solid var(--card-border);
        }

        body.theme-modern-light .file-tab {
            color: var(--text-secondary);
        }

        body.theme-modern-light .file-tab.active {
            background-color: rgba(108, 92, 231, 0.05);
            color: var(--primary);
            border-left: 3px solid var(--primary);
        }

        body.theme-modern-light .comprehension-stats {
            background-color: var(--surface);
            border: 1px solid var(--card-border);
        }

        body.theme-modern-light .progress-segment.segment-base {
            background: #dfe6e9;
        }

        body.theme-modern-light .progress-segment.segment-start {
            background: #81ecec;
        }

        body.theme-modern-light .progress-segment.segment-target {
            background: #00cec9;
        }

        body.theme-modern-light .btn-ignore {
            background-color: #f1f2f6;
            color: #636e72;
        }

        body.theme-modern-light .btn-ignore:hover {
            background-color: #ffeaa7;
            color: #d63031;
        }

        body.theme-modern-light .card {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            border: 1px solid transparent;
        }

        /* --- THEME: Zen Focus --- */
        body.theme-zen-focus {
            --background: #000000;
            --surface: #000000;
            --card-border: #111;
            --primary: #ffffff;
            --secondary: #ffffff;
            --on-background: #bbbbbb;
            --text-secondary: #555;
        }

        body.theme-zen-focus .header-logo,
        body.theme-zen-focus .main-tabs,
        body.theme-zen-focus header h1,
        body.theme-zen-focus .tier-badge,
        body.theme-zen-focus .card-footer {
            opacity: 0.1;
            /* Fade out non-essentials */
            transition: opacity 0.3s;
        }

        body.theme-zen-focus header:hover .header-logo,
        body.theme-zen-focus header:hover h1,
        body.theme-zen-focus .card:hover .card-footer {
            opacity: 1;
        }

        body.theme-zen-focus .word-main {
            color: #fff;
        }

        body.theme-zen-focus .context-box {
            color: #999;
        }

        body.theme-zen-focus .context-box em {
            color: #fff;
            font-weight: bold;
            text-decoration: underline;
        }

        /* Zen Mode Layout Override */
        body.theme-zen-focus .progressive-container {
            display: block !important;
            /* Override grid */
            max-width: 800px;
            margin: 0 auto;
            padding: 0 20px;
        }

        body.theme-zen-focus .file-sidebar {
            display: none !important;
        }

        /* Zen Mode: Hide Toggles & Ensure Visibility */
        body.theme-zen-focus #btn-toggle-sentences,
        body.theme-zen-focus .toggle-contexts-btn {
            display: none !important;
        }

        body.theme-zen-focus .zen-file-title {
            color: var(--primary);
            opacity: 0.9;
            text-align: left;
            margin-top: 80px;
            border-bottom: 2px solid #333;
            padding-bottom: 12px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.8rem;
            letter-spacing: 1px;
        }

        body.theme-zen-focus .card {
            background: transparent;
            border: none;
            border-bottom: 1px solid #111;
            padding: 30px 0;
            margin-bottom: 0;
        }

        body.theme-zen-focus .word-main {
            font-size: 2.2rem;
            font-weight: bold;
        }

        body.theme-zen-focus .context-item-zen {
            font-size: 1.2rem;
            line-height: 1.8;
            color: #ccc;
            margin-bottom: 25px;
        }

        body.theme-zen-focus .context-item-zen em {
            color: #fff;
            font-style: normal;
            font-weight: bold;
            border-bottom: 2px solid #ff4b2b;
            /* subtle highlight like the screenshot */
        }

        /* --- Navigation Hint --- */
        #nav-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(98, 0, 238, 0.2);
            color: var(--on-background);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: help;
            z-index: 1000;
            opacity: 0.4;
            transition: opacity 0.3s, background-color 0.3s;
            font-size: 1.1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #nav-hint:hover {
            opacity: 1;
            background-color: var(--primary);
        }

        #nav-hint .hint-tooltip {
            visibility: hidden;
            width: 220px;
            background-color: var(--surface);
            color: var(--on-surface);
            text-align: center;
            border-radius: 8px;
            padding: 12px;
            position: absolute;
            z-index: 1001;
            bottom: 45px;
            right: 0;
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);
            border: 1px solid var(--card-border);
            font-size: 0.9rem;
            pointer-events: none;
            line-height: 1.4;
        }

        #nav-hint:hover .hint-tooltip {
            visibility: visible;
            opacity: 1;
        }

        .target-met-inline {
            color: #4caf50;
            font-size: 0.85em;
            margin-left: 10px;
            font-weight: bold;
            letter-spacing: 0.5px;
        }
    </style>
</head>

<body>
    <div id="loading-screen">
        <div class="spinner"></div>
        <p>Analyzing Library...</p>
    </div>

    <div id="nav-hint">
        ⓘ
        <div class="hint-tooltip">Tip: Use <b>Left/Right keys</b> or <b>Space</b> to quickly move between words. Use
            <b>Up/Down keys</b> to show or hide sentences.
        </div>
    </div>
    <header>
        <h1>Surasura List</h1>
    </header>
    <div id="content-area">
        <!-- Progressive View -->
        <div id="view-progressive" class="view active">
            <div class="progressive-container">
                <div class="file-sidebar" id="file-tabs">
                    <!-- File tabs injected here -->
                </div>
                <div class="word-list-container" id="progressive-list">
                    <!-- Cards injected here -->
                </div>
            </div>
        </div>
        <!-- Priority View -->
        <div id="view-priority" class="view">
            <div class="word-list-container" id="priority-list">
                <!-- Cards injected here -->
            </div>
        </div>
    </div>

    <script>
        // --- Efficient Chunked Rendering Helper ---
        async function renderChunked(container, items, createFn, chunkSize = 25) {
            let index = 0;
            return new Promise(resolve => {
                function next() {
                    if (index >= items.length) {
                        resolve();
                        return;
                    }

                    const chunk = items.slice(index, index + chunkSize);
                    const fragment = document.createDocumentFragment();

                    chunk.forEach(item => {
                        fragment.appendChild(createFn(item));
                    });

                    container.appendChild(fragment);
                    index += chunkSize;

                    // Yield to main thread for responsiveness
                    requestAnimationFrame(next);
                }
                next();
            });
        }
    </script>

    <script>
        let globalData = null;
        let ignoredWords = new Set();

        // Determine storage key based on language
        // Valid for new exports. For legacy files, it might default to 'ja' or undefined.
        // We can check if globalLanguage exists.
        const langSuffix = (typeof globalLanguage !== 'undefined') ? globalLanguage : 'ja';
        const storageKey = `surasura_ignored_words_${langSuffix}`;

        // --- Local Storage Ignore Logic ---
        try {
            const stored = localStorage.getItem(storageKey);
            if (stored) {
                ignoredWords = new Set(JSON.parse(stored));
                console.log(`Loaded ${ignoredWords.size} ignored words from local storage (${storageKey}).`);
            } else if (langSuffix !== 'ja') {
                // Fallback migration: If specific lang key empty, check legacy key 'surasura_ignored_words'
                // But only if we think we might be migrating. 
                // Actually, safeguard: Let's NOT migrate automatically to avoid mixing langs.
                // User starts fresh for new languages.
            }
        } catch (e) {
            console.error("Failed to load ignored words", e);
        }

        function saveIgnoredWords() {
            localStorage.setItem(storageKey, JSON.stringify([...ignoredWords]));
        }

        function clearIgnoredWords() {
            if (confirm(`Are you sure you want to un-hide all ignored words for ${langSuffix}?`)) {
                ignoredWords.clear();
                localStorage.removeItem(storageKey);
                location.reload();
            }
        }

        function copyIgnoredWords() {
            const text = [...ignoredWords].join('\n');
            navigator.clipboard.writeText(text).then(() => {
                const btn = document.getElementById('btn-copy-ignore');
                if (btn) {
                    const original = btn.textContent;
                    btn.textContent = "Copied!";
                    setTimeout(() => btn.textContent = original, 2000);
                }
            }).catch(err => {
                console.error("Copy failed", err);
                alert("Copy failed. See console.");
            });
        }

        function styleIgnoreButton(btn) {
            btn.style.background = 'rgba(255,255,255,0.1)';
            btn.style.border = '1px solid rgba(255,255,255,0.2)';
            btn.style.color = '#ddd';
            btn.style.padding = '5px 10px';
            btn.style.borderRadius = '4px';
            btn.style.cursor = 'pointer';
            btn.style.fontSize = '0.8rem';
            btn.style.transition = 'background 0.2s';
            btn.onmouseover = () => btn.style.background = 'rgba(255,255,255,0.2)';
            btn.onmouseout = () => btn.style.background = 'rgba(255,255,255,0.1)';
        }

        function updateClearButtonVisibility() {
            const header = document.querySelector('header');
            if (!header) return;

            // Container for ignore buttons
            let container = document.getElementById('ignore-controls');
            if (!container) {
                container = document.createElement('div');
                container.id = 'ignore-controls';
                container.style.marginLeft = 'auto'; // Push to right
                container.style.display = 'flex';
                container.style.gap = '10px';
                container.style.alignItems = 'center';
                container.style.marginRight = '20px';
                header.appendChild(container);
            }

            // Un-hide Button
            // ... (existing code for unhide button) ...

            // Inject Toggle Sentences Button if not present

            let btnClear = document.getElementById('btn-clear-ignore');
            if (!btnClear) {
                btnClear = document.createElement('button');
                btnClear.id = 'btn-clear-ignore';
                btnClear.onclick = clearIgnoredWords;
                styleIgnoreButton(btnClear);
                // If it existed before (created by old code), appendChild moves it here
            }
            if (container.lastChild !== btnClear && container.firstChild !== btnClear) {
                container.appendChild(btnClear);
            }

            // Copy Button
            let btnCopy = document.getElementById('btn-copy-ignore');
            if (!btnCopy) {
                btnCopy = document.createElement('button');
                btnCopy.id = 'btn-copy-ignore';
                btnCopy.textContent = "Copy Ignored Words";
                btnCopy.title = "Paste these into your ignored List";
                btnCopy.onclick = copyIgnoredWords;
                styleIgnoreButton(btnCopy);
                container.appendChild(btnCopy);
            }

            // Inject Toggle Sentences Button (ALWAYS VISIBLE, Rightmost)
            if (!document.getElementById('btn-toggle-sentences')) {
                const toggleBtn = document.createElement('button');
                toggleBtn.id = 'btn-toggle-sentences';
                toggleBtn.innerHTML = "▼";
                toggleBtn.title = "Expand All Sentences";
                styleIgnoreButton(toggleBtn);
                toggleBtn.style.marginLeft = "10px"; // Spacing from copy button
                toggleBtn.style.minWidth = "30px";
                toggleBtn.onclick = toggleAllSentences;

                // Append to end
                container.appendChild(toggleBtn);
            } else {
                // Ensure it is at the end if already exists (e.g. re-renders)
                container.appendChild(document.getElementById('btn-toggle-sentences'));
            }

            const hasIgnored = ignoredWords.size > 0;
            // Container always visible now because it holds the Toggle Button
            container.style.display = 'flex';

            const isZen = typeof globalTheme !== 'undefined' && globalTheme && globalTheme.toLowerCase() === 'zen focus';
            const showIgnoreApps = hasIgnored && !isZen;

            // Toggle visibility of ignore-specific buttons
            if (btnClear) btnClear.style.display = showIgnoreApps ? 'inline-block' : 'none';
            if (btnCopy) btnCopy.style.display = showIgnoreApps ? 'inline-block' : 'none';

            // Fix variable name usage from previous block context if needed, or re-select
            const bCopy = document.getElementById('btn-copy-ignore');
            if (bCopy) bCopy.style.display = showIgnoreApps ? 'inline-block' : 'none';

            if (hasIgnored) {
                btnClear.textContent = `Un-hide All (${ignoredWords.size})`;
            }

            // --- Enforce Zen Mode Layout for Dark Flow / Zen Focus ---
            if (isZen) {
                // 1. Center Title
                const h1 = document.querySelector('header h1');
                if (h1) {
                    h1.style.textAlign = 'center';
                    h1.style.flex = '1';
                    h1.style.margin = '0';
                    // If logo exists (injected by python), center the container
                    if (h1.parentElement.tagName === 'DIV' && h1.parentElement.style.display === 'flex') {
                        h1.parentElement.style.justifyContent = 'center';
                        h1.parentElement.style.width = '100%';
                    }
                }

                // 2. Hide Extra Buttons (Theme, Settings, Github)
                // Assuming they are usually children of header or a container.
                // We want to KEEP: Title, logo, and btn-toggle-sentences.
                // We want to HIDE: everything else.

                const header = document.querySelector('header');
                if (header) {
                    Array.from(header.children).forEach(child => {
                        // Keep Title Container (div with logo+h1) or H1 itself
                        const isTitle = child.tagName === 'H1' || (child.tagName === 'DIV' && child.querySelector('h1'));
                        // Keep Toggle Button Container (ignore-controls)
                        const isIgnoreControls = child.id === 'ignore-controls';

                        if (!isTitle && !isIgnoreControls) {
                            child.style.display = 'none';
                        }
                    });
                }
            }
        }

        // --- Initialization ---
        window.addEventListener('load', async () => {
            try {
                const isZen = typeof globalTheme !== 'undefined' && globalTheme && globalTheme.toLowerCase() === 'zen focus';

                if (typeof globalTheme !== 'undefined' && globalTheme) {
                    // Sanitize theme name for class usage (remove spaces/parens)
                    const themeClass = 'theme-' + globalTheme.replace(/[^a-zA-Z0-9-_]/g, '-');
                    document.body.classList.add(themeClass);
                } else {
                    document.body.classList.add('theme-default');
                }

                // Injected tabs if NOT zen
                if (!isZen) {
                    const header = document.querySelector('header');
                    const tabsDiv = document.createElement('div');
                    tabsDiv.className = 'main-tabs';
                    tabsDiv.innerHTML = `
                        <button class="main-tab-btn active" onclick="switchMainTab('progressive')">Progressive Learning</button>
                        <button class="main-tab-btn" onclick="switchMainTab('priority')">Priority List</button>
                    `;
                    header.appendChild(tabsDiv);
                }

                updateClearButtonVisibility();

                // --- Filter Global Data with Local Ignore List ---
                if (globalData && ignoredWords.size > 0) {
                    // Filter Progressive
                    if (globalData.progressive) {
                        globalData.progressive.forEach(file => {
                            if (file.words) {
                                file.words = file.words.filter(w => !ignoredWords.has(w.Word));
                            }
                        });
                    }
                    // Filter Priority
                    if (globalData.priority) {
                        globalData.priority = globalData.priority.filter(w => !ignoredWords.has(w.Word));
                    }
                }

                await fetchData();
            } catch (e) {
                console.error("Initialization Error:", e);
                const loader = document.getElementById('loading-screen');
                if (loader) loader.innerHTML = `<p style='color:red; background:white; padding:20px;'>Initialization Error: ${e.message}</p>`;
            }
        });

        async function fetchData() {

            // Static Mode: Data is already injected into globalData
            try {
                // Hide loading
                document.getElementById('loading-screen').style.display = 'none';

                // Render Views
                const isZen = typeof globalTheme !== 'undefined' && globalTheme && globalTheme.toLowerCase() === 'zen focus';
                await renderProgressiveView();
                if (!isZen) {
                    await renderPriorityView();
                } else {
                    const priorityView = document.getElementById('view-priority');
                    if (priorityView) priorityView.remove();
                }

            }

            catch (error) {
                console.error("Error rendering data:", error);
                document.getElementById('loading-screen').innerHTML = "<p style='color:red'>Error rendering data. Check console.</p>";
            }
        }

        // --- Tabs Logic (With DOM Detachment) ---
        async function switchMainTab(tabName) {
            if (document.querySelector(`.main-tab-btn[onclick="switchMainTab('${tabName}')"]`).classList.contains('active')) return;

            // 1. Update UI Tabs
            document.querySelectorAll('.main-tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.main-tab-btn[onclick="switchMainTab('${tabName}')"]`).classList.add('active');

            // 2. Hide all views & Detach DOM (Save memory)
            document.querySelectorAll('.view').forEach(view => {
                view.classList.remove('active');
                // Optional: Clear innerHTML to free memory?
                // For now, let's just clear the *other* view's container if it's heavy?
                // Actually, let's try a simple re-render approach.
                // When leaving a tab, we empty it?
            });

            // 3. Show active view
            const activeView = document.getElementById(`view-${tabName}`);
            activeView.classList.add('active');

            // 4. Lazy Re-render (if empty)
            if (tabName === 'progressive') {
                // If container is empty, re-render
                const container = document.getElementById('progressive-list');
                if (!container.hasChildNodes()) {
                    await renderProgressiveView();
                }
                // Detach Priority
                document.getElementById('priority-list').innerHTML = "";
            } else if (tabName === 'priority') {
                const container = document.getElementById('priority-list');
                if (!container.hasChildNodes()) {
                    await renderPriorityView();
                }
                // Detach Progressive
                document.getElementById('file-tabs').innerHTML = "";
                document.getElementById('progressive-list').innerHTML = "";
            }
        }

        // --- Progressive View Rendering ---
        async function renderProgressiveView() {
            const tabsContainer = document.getElementById('file-tabs');
            const listContainer = document.getElementById('progressive-list');
            const isZen = typeof globalTheme !== 'undefined' && globalTheme && globalTheme.toLowerCase() === 'zen focus';

            tabsContainer.innerHTML = "";
            listContainer.innerHTML = "";

            if (!globalData.progressive || globalData.progressive.length === 0) {
                listContainer.innerHTML = "<p style='padding:20px'>No progressive data available.</p>";
                return;
            }

            if (isZen) {
                // Continuous Scroll for Zen (Infinite Scroll applied to Files!)
                // CSS handles hiding sidebar and reshaping container

                // Use infinite scroll for files themselves

                // Use infinite scroll for files themselves
                setupInfiniteScroll(listContainer, globalData.progressive, createZenFileSection, 3); // Load 3 files at a time? 

                // Render completed files (Zen Mode) - summary list at bottom
                if (globalData.completed_files && globalData.completed_files.length > 0) {
                    const completedSection = document.createElement('div');
                    completedSection.className = 'zen-file-section';
                    completedSection.innerHTML = `<h2 class="zen-file-title" style="margin-top:60px; border-bottom:1px solid #333; padding-bottom:5px; color:#4caf50;">Completed Files (${globalData.completed_files.length})</h2><p style="color:#888; font-style:italic;">These files require no new learning to meet your target coverage.</p>`;

                    globalData.completed_files.forEach(file => {
                        const fDiv = document.createElement('div');
                        fDiv.style.padding = "10px 0";
                        fDiv.style.borderBottom = "1px solid #222";
                        fDiv.style.color = "#aaa";
                        const stats = file.stats || {};
                        fDiv.innerHTML = `<div style="display:flex; justify-content:space-between;"><span>${file.filename}</span><span>${stats["Coverage (%)"]}% Coverage</span></div>`;
                        completedSection.appendChild(fDiv);
                    });
                    listContainer.appendChild(completedSection);
                }

            } else {
                const inlineCompleted = (typeof globalLogic !== 'undefined' && globalLogic.inline_completed_files);

                // Prepare file list including completed if needed
                let fileList = [];
                const progFiles = new Map((globalData.progressive || []).map(f => [f.filename, f]));

                if (inlineCompleted && globalData.file_order && globalData.file_order.length > 0) {
                    const compFiles = new Map((globalData.completed_files || []).map(f => [f.filename, f]));

                    globalData.file_order.forEach(fname => {
                        if (progFiles.has(fname)) fileList.push({ type: 'prog', data: progFiles.get(fname) });
                        else if (compFiles.has(fname)) fileList.push({ type: 'comp', data: compFiles.get(fname) });
                    });
                } else {
                    // Standard Order
                    globalData.progressive.forEach(f => fileList.push({ type: 'prog', data: f }));
                }

                if (fileList.length > 500) {
                    setupInfiniteScroll(tabsContainer, fileList, createSidebarTab, 50);
                } else {
                    fileList.forEach((item, index) => {
                        tabsContainer.appendChild(createSidebarTab(item));
                    });

                    // Render Completed divider manually if not inline?
                    if (!inlineCompleted && globalData.completed_files && globalData.completed_files.length > 0) {
                        const divider = document.createElement('div');
                        divider.innerHTML = `<div style="padding: 15px 20px; color: #4caf50; font-size: 0.8rem; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid rgba(255,255,255,0.1); margin-top: 10px;">Target Met</div>`;
                        tabsContainer.appendChild(divider);

                        globalData.completed_files.forEach(f => {
                            tabsContainer.appendChild(createSidebarTab({ type: 'comp', data: f }));
                        });
                    }
                }

                // Initial Load
                if (fileList.length > 0) {
                    // Activate first tab visually (if present)
                    setTimeout(() => {
                        const firstTab = tabsContainer.querySelector('.file-tab');
                        if (firstTab) {
                            firstTab.classList.add('active');
                            firstTab.click(); // Trigger load
                        }
                    }, 50);
                }
            }
        }

        function createZenFileSection(fileData) {
            const fileSection = document.createElement('div');
            fileSection.className = 'zen-file-section';

            let titleHtml = fileData.filename;
            if (fileData.is_goal_content) {
                titleHtml += ` <span style="font-size:0.6em; color:#4caf50; vertical-align:middle; border:1px solid #4caf50; padding:2px 6px; border-radius:4px; margin-left:10px;">GOAL</span>`;
            }

            fileSection.innerHTML = `<h2 class="zen-file-title">${titleHtml}</h2>`;

            const stats = calculateFileStats(fileData.words);
            if (stats) {
                fileSection.appendChild(createComprehensionBar(stats));
            }

            // Container for words
            const wordsContainer = document.createElement('div');
            fileSection.appendChild(wordsContainer);

            // Trigger Infinite Scroll for words inside this file
            // Delay slightly to let file rendering finish?
            requestAnimationFrame(() => {
                try {
                    const chunkSize = (typeof globalLogic !== 'undefined' && globalLogic.chunk_size) ? globalLogic.chunk_size : 50;

                    // Always use cards now, thanks to Infinite Scroll perf.
                    setupInfiniteScroll(wordsContainer, fileData.words, createWordCard, chunkSize);
                } catch (e) {
                    console.error("Error setting up infinite scroll for file:", fileData.filename, e);
                    wordsContainer.innerHTML = `<p style="color:red">Error loading words: ${e.message}</p>`;
                }
            });

            return fileSection;
        }

        function createSidebarTab(item) {
            const tab = document.createElement('div');
            tab.className = `file-tab`;

            if (item.type === 'prog') {
                const fileData = item.data;

                let goalIndicator = "";
                if (fileData.is_goal_content) {
                    // Make it more visible: a small text badge
                    goalIndicator = `<span style="display:inline-block; background-color:rgba(76, 175, 80, 0.2); color:#4caf50; border:1px solid #4caf50; border-radius:3px; font-size:0.7em; padding:0 4px; margin-right:6px; font-weight:bold;" title="Goal Content">G</span>`;
                }

                tab.innerHTML = `${goalIndicator}<span>${fileData.filename}</span> <span style="font-size: 0.9em; opacity: 0.5; margin-left: 8px; font-family: monospace;">(${fileData.words.length})</span>`;
                tab.onclick = async () => {
                    document.querySelectorAll('.file-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    await renderFileWords(fileData.words, fileData.is_goal_content);
                }
            } else {
                const fileData = item.data;
                tab.style.opacity = "0.7";
                tab.innerHTML = `<span>${fileData.filename}</span> <span class="target-met-inline">Target met ✓</span>`;
                tab.onclick = () => {
                    document.querySelectorAll('.file-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    renderCompletedFile(fileData);
                }
            }
            return tab;
        }

        async function renderCompletedFile(fileData) {
            const listContainer = document.getElementById('progressive-list');
            listContainer.innerHTML = "";

            const stats = fileData.stats || {};
            const coverage = parseFloat(stats["Coverage (%)"]) || 100;
            const known = stats["Known Count"] || 0;
            const total = stats["Total Words"] || 0;

            const content = `
                <div style="padding: 40px; text-align: center; color: var(--text-secondary);">
                    <div style="font-size: 4rem; margin-bottom: 20px; color: #4caf50;">✓</div>
                    <h2 style="color: var(--on-surface);">Target Met</h2>
                    <p style="font-size: 1.2rem; margin-bottom: 30px;">
                        You have already met your target coverage for <strong>${fileData.filename}</strong>.
                    </p>
                    
                    <div style="display: inline-block; text-align: left; background: var(--surface); padding: 20px; border-radius: 8px; border: 1px solid var(--card-border); min-width: 300px;">
                        <div style="margin-bottom: 10px; display:flex; justify-content:space-between;">
                            <span>Coverage</span>
                            <strong style="color: #4caf50;">${coverage}%</strong>
                        </div>
                        <div style="margin-bottom: 10px; display:flex; justify-content:space-between;">
                            <span>Known Words</span>
                            <strong>${known} / ${total}</strong>
                        </div>
                        <div style="width: 100%; height: 8px; background: #333; border-radius: 4px; overflow: hidden; margin-top: 15px;">
                            <div style="width: ${coverage}%; height: 100%; background: #4caf50;"></div>
                        </div>
                    </div>
                </div>
            `;
            listContainer.innerHTML = content;
        }

        // --- Infinite Scroll Helper ---
        function setupInfiniteScroll(container, items, createFn, chunkSize = 50) {
            let index = 0;

            // Create Sentinel
            const sentinel = document.createElement('div');
            sentinel.className = 'scroll-sentinel';
            sentinel.style.height = "50px";
            sentinel.style.textAlign = "center";
            sentinel.style.color = "#666";
            sentinel.style.padding = "20px";
            sentinel.innerText = "Loading more...";
            container.appendChild(sentinel);

            const observer = new IntersectionObserver((entries) => {
                if (entries[0].isIntersecting) {
                    loadNextChunk();
                }
            }, { root: null, rootMargin: "200px" });

            function loadNextChunk() {
                if (index >= items.length) {
                    sentinel.innerText = "End of list";
                    sentinel.style.opacity = "0.5";
                    observer.disconnect();
                    return;
                }

                // Render Chunk
                const end = Math.min(index + chunkSize, items.length);
                const fragment = document.createDocumentFragment();

                for (let i = index; i < end; i++) {
                    fragment.appendChild(createFn(items[i]));
                }

                // Insert before sentinel
                container.insertBefore(fragment, sentinel);
                index = end;

                // Stop if done
                if (index >= items.length) {
                    sentinel.innerText = "";
                    sentinel.style.height = "0";
                    sentinel.style.padding = "0";
                    observer.disconnect();
                }
            }

            observer.observe(sentinel);

            // Initial load
            loadNextChunk();
        }

        async function renderFileWords(words, isGoalContent = false) {
            const listContainer = document.getElementById('progressive-list');
            // Do NOT clear listContainer here if we want to keep previous files in Zen mode?
            // Actually, for Progressive View (non-Zen), we clear it.
            // For Zen, we append.
            const isZen = typeof globalTheme !== 'undefined' && globalTheme && globalTheme.toLowerCase() === 'zen focus';

            if (!isZen) {
                listContainer.innerHTML = "";
            }

            if (!words || words.length === 0) {
                if (!isZen) listContainer.innerHTML = "<p style='padding:20px; color:#aaa'>No new words in this file.</p>";
                return;
            }

            // Create Comprehension Bar
            const stats = calculateFileStats(words);
            // In Zen mode, the bar is inside the file section, handled by caller
            if (!isZen) {
                const statsBar = createComprehensionBar(stats);
                listContainer.appendChild(statsBar);
            }

            const chunkSize = (typeof globalLogic !== 'undefined' && globalLogic.chunk_size) ? globalLogic.chunk_size : 50;

            // Usage of isGoalContent now only for visual indication (e.g. sidebar badge), 
            // no longer restricting the view to sentences-only since Infinite Scroll handles the perf.

            // Just use standard rendering for everything
            setupInfiniteScroll(listContainer, words, createWordCard, chunkSize);
        }

        function createSimpleSentenceRow(data) {
            const el = document.createElement('div');
            el.style.contain = "content"; // CSS Optimization
            el.style.contentVisibility = "auto";
            el.style.containIntrinsicSize = "1px 60px";

            el.style.padding = "8px 15px";
            el.style.borderBottom = "1px solid rgba(255,255,255,0.05)";
            el.style.color = "#ccc";
            el.style.fontSize = "0.95rem";

            const word = escapeHtml(data.Word);
            const context = data["Context 1"] || data.Context || "";

            // Highlight word
            const safeCtx = escapeHtml(context);
            const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(escapedWord, 'gi');
            const displayCtx = safeCtx.replace(regex, `<strong style="color:var(--primary);">${word}</strong>`);

            el.innerHTML = `<span style="display:inline-block; width:80px; font-size:0.8rem; color:var(--text-secondary); vertical-align:top; margin-right:10px;">${word}</span><span style="display:inline-block; max-width: 800px;">${displayCtx}</span>`;
            return el;
        }

        function calculateFileStats(words) {
            if (!words.length) return null;
            const first = words[0];
            const last = words[words.length - 1];

            return {
                baseline: parseFloat(first["Baseline %"]) || 0,
                start: parseFloat(first["Current %"]) || 0,
                target: parseFloat(last["New %"]) || 0,
                known: last["Known Count"] || 0,
                total: last["Total Count"] || 0
            };
        }

        function createComprehensionBar(stats) {
            const isZen = typeof globalTheme !== 'undefined' && globalTheme && globalTheme.toLowerCase() === 'zen focus';
            const el = document.createElement('div');
            el.className = 'comprehension-stats';

            const baseWidth = stats.baseline;
            const startWidth = stats.start - stats.baseline;
            const targetWidth = stats.target - stats.start;
            const remainingWidth = 100 - stats.target;

            const countsHtml = isZen ? '' : `<span style="opacity: 0.5; margin-right: 12px; font-size: 0.85em;">(${stats.known} / ${stats.total})</span>`;

            el.innerHTML = ` <div class="stats-row"><span style="font-weight: bold; color: var(--secondary);">Learning Growth</span><span>${countsHtml}Target: <strong>${stats.target.toFixed(2)}%</strong></span></div><div class="progress-container"><div class="progress-segment segment-base" style="width: ${baseWidth}%" title="Baseline: ${stats.baseline}%"></div><div class="progress-segment segment-start" style="width: ${startWidth}%" title="Previous Progress: ${(stats.start - stats.baseline).toFixed(2)}%"></div><div class="progress-segment segment-target" style="width: ${targetWidth}%" title="Target Progress: ${(stats.target - stats.start).toFixed(2)}%"></div></div><div class="legend"><div class="legend-item"><span class="dot" style="background: #4caf50; opacity: 0.3;"></span>Baseline (${stats.baseline.toFixed(1)}%)</div><div class="legend-item"><span class="dot" style="background: #4caf50; opacity: 0.6;"></span>Carried Over (+${(stats.start - stats.baseline).toFixed(1)}%)</div><div class="legend-item"><span class="dot" style="background: #4caf50;"></span>This File (+${(stats.target - stats.start).toFixed(1)}%)</div></div>`;
            return el;
        }

        // --- Priority View Rendering ---
        async function renderPriorityView() {
            const container = document.getElementById('priority-list');
            container.innerHTML = "";

            if (!globalData.priority || globalData.priority.length === 0) {
                container.innerHTML = "<p>No priority data available.</p>";
                return;
            }

            // Infinite Scroll handles slicing, so no need to pre-slice
            const chunkSize = (typeof globalLogic !== 'undefined' && globalLogic.chunk_size) ? globalLogic.chunk_size : 50;
            // Cap at 25 for heavy cards unless user specified?
            // Let's just use the setting directly.
            setupInfiniteScroll(container, globalData.priority, createWordCard, chunkSize);
        }

        // --- Global Sentence Toggle ---
        let globalShowAllSentences = false;

        function toggleAllSentences() {
            globalShowAllSentences = !globalShowAllSentences;
            const btn = document.getElementById('btn-toggle-sentences');
            if (btn) {
                btn.innerHTML = globalShowAllSentences ? "▲" : "▼";
                btn.title = globalShowAllSentences ? "Collapse All Sentences" : "Expand All Sentences";
                btn.classList.toggle('active', globalShowAllSentences);
            }

            // Update existing cards
            // Update existing cards
            document.querySelectorAll('.card').forEach(card => {
                const toggleBtn = card.querySelector('.toggle-contexts-btn');
                if (toggleBtn) {
                    const extraDiv = card.querySelector('.extra-contexts');
                    const isVisible = extraDiv.classList.contains('visible');

                    // If Global ON and NOT visible -> Click to expand
                    if (globalShowAllSentences && !isVisible) {
                        toggleBtn.click();
                    }
                    // If Global OFF and IS visible -> Click to collapse
                    else if (!globalShowAllSentences && isVisible) {
                        toggleBtn.click();
                    }
                }
            });
        }

        // --- Card Component ---
        // --- Word Card Component (Optimized) ---
        function createWordCard(data) {
            const isZen = typeof globalTheme !== 'undefined' && globalTheme && globalTheme.toLowerCase() === 'zen focus';
            const el = document.createElement('div');
            el.className = 'card';

            const word = data.Word;
            const safeWord = escapeHtml(word);

            const escapedWordForRegex = safeWord.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&');
            const regex = new RegExp(escapedWordForRegex, 'gi');

            function formatContext(ctx) {
                if (!ctx) return "";
                const safeCtx = escapeHtml(ctx);
                return safeCtx.replace(regex, `<em>${safeWord}</em>`);
            }

            const c1 = data["Context 1"] || data.Context || "";
            const displayC1 = formatContext(c1);

            if (isZen) {
                const c2 = data["Context 2"] || "";
                const c3 = data["Context 3"] || "";
                const dC2 = formatContext(c2);
                const dC3 = formatContext(c3);

                const freq = data["Occurrences (Global)"] !== undefined ? data["Occurrences (Global)"] : (data.Occurrences !== undefined ? data.Occurrences : null);
                const displayFreq = (freq !== null) ? `<span class="freq-zen" style="margin-left:auto; opacity:0.6; font-size:1.0rem; font-family:monospace;">F:${freq}</span>` : '';

                // Priority Logic from Settings
                const pm = (typeof globalLogic !== 'undefined' && globalLogic.priority_markers) ? globalLogic.priority_markers : { priority_threshold: 0.5, priority_min: 3, lopsided_threshold: 0.8 };

                const high = parseInt(data["Count (High)"]) || 0;
                const low = parseInt(data["Count (Low)"]) || 0;
                const total = parseInt(data["Occurrences (Global)"] !== undefined ? data["Occurrences (Global)"] : (data.Occurrences !== undefined ? data.Occurrences : 0)) || 0;

                let markersHtml = '';
                if (total > 0 && (high / total) >= pm.lopsided_threshold) {
                    markersHtml += `<span class="priority-marker marker-lopsided" title="High Priority content contains ${(pm.lopsided_threshold * 100).toFixed(0)}%+ of occurrences (Lopsided)"></span>`;
                } else if (total >= pm.priority_min && ((high + low) / total) >= pm.priority_threshold) {
                    markersHtml += `<span class="priority-marker marker-priority" title="High/Low Priority content contains ${(pm.priority_threshold * 100).toFixed(0)}%+ of occurrences (Priority)"></span>`;
                }

                el.innerHTML = `
                    <div class="card-header" style="margin-bottom:15px; display:flex; align-items:baseline;">
                        <span class="word-main">${safeWord}</span>
                        <span class="reading" style="margin-left: 15px; font-size: 1.3rem; opacity: 0.7;">${data.Reading || ''}</span>
                        ${displayFreq}
                        <div style="margin-left:12px; display:flex; align-items:center;">${markersHtml}</div>
                    </div>
                    <div class="context-box">
                        <div class="context-item-zen">${displayC1}</div>
                        ${c2 ? `<div class="context-item-zen">${dC2}</div>` : ''}
                        ${c3 ? `<div class="context-item-zen">${dC3}</div>` : ''}
                    </div>
                `;
                return el;
            }

            // Parse Tier data and create tier badges
            let tierBadgesHtml = '';
            if (data.Tier) {
                const tierStr = String(data.Tier).trim();
                if (tierStr === 'Outside') {
                    tierBadgesHtml = '';
                } else {
                    // Format: "Source1:Tier1;Source2:Tier2" or old format "1"
                    const tierParts = tierStr.split(';');
                    tierBadgesHtml = tierParts.map(part => {
                        if (part.includes(':')) {
                            const [source, tier] = part.split(':');

                            // Strictly abbreviate to the first letter in caps
                            // e.g., "global50k" -> "G", "anime" -> "A"
                            let displaySource = source.charAt(0).toUpperCase();

                            // Format: "G-3"
                            return `<span class="tier-badge tier-${tier}" title="${source}">${displaySource}-${tier}</span>`;
                        } else {
                            // Fallback for old format
                            return `<span class="tier-badge tier-${part}">${part}</span>`;
                        }
                    }).join('');
                }
            }

            // Standard Card: Base HTML
            el.innerHTML = `
                <div class="card-header">
                    <div style="display:flex; align-items:center; gap: 10px;">
                        <span class="word-main">${safeWord}</span>
                        <span class="reading" data-reading="${data.Reading || ''}" migaku_ignore data-yomichan-ignore></span>
                    </div>
                    <div style="display:flex; align-items:center; gap: 15px;">
                        <div class="stats" style="font-size: 0.9rem; color: var(--text-secondary);">
                            ${data.Score !== undefined ? `<span>Score: ${data.Score}</span>` : ''}
                            ${(data["Occurrences (Global)"] !== undefined) ? `<span>Freq: ${data["Occurrences (Global)"]}</span>` : (data.Occurrences !== undefined ? `<span>Freq: ${data.Occurrences}</span>` : '')}
                        </div>
                        ${(() => {
                    const pm = (typeof globalLogic !== 'undefined' && globalLogic.priority_markers) ? globalLogic.priority_markers : { priority_threshold: 0.5, priority_min: 3, lopsided_threshold: 0.8 };
                    const high = parseInt(data["Count (High)"]) || 0;
                    const low = parseInt(data["Count (Low)"]) || 0;
                    const total = parseInt(data["Occurrences (Global)"] !== undefined ? data["Occurrences (Global)"] : (data.Occurrences !== undefined ? data.Occurrences : 0)) || 0;
                    let html = '';
                    if (total > 0 && (high / total) >= pm.lopsided_threshold) {
                        html += `<span class="priority-marker marker-lopsided" title="High Priority content contains ${(pm.lopsided_threshold * 100).toFixed(0)}%+ of occurrences (Lopsided)"></span>`;
                    } else if (total >= pm.priority_min && ((high + low) / total) >= pm.priority_threshold) {
                        html += `<span class="priority-marker marker-priority" title="High/Low Priority content contains ${(pm.priority_threshold * 100).toFixed(0)}%+ of occurrences (Priority)"></span>`;
                    }
                    return html;
                })()}
                        <div style="display:flex; gap: 5px; flex-wrap: wrap;">
                            ${tierBadgesHtml}
                        </div>
                    </div>
                </div>
                <div class="context-box">${displayC1}</div>
            `;

            // Extra Contexts (DOM Pruning)
            const c2 = data["Context 2"] || "";
            const c3 = data["Context 3"] || "";
            if (c2 || c3) {
                const extraDiv = document.createElement('div');
                extraDiv.className = "extra-contexts";

                // --- ZEN MODE LOGIC ---
                if (isZen) {
                    // Always show, no toggle, no lazy load
                    const dC2 = formatContext(c2);
                    const dC3 = formatContext(c3);
                    extraDiv.innerHTML = `${c2 ? `<div class="context-item">${dC2}</div>` : ''}${c3 ? `<div class="context-item">${dC3}</div>` : ''}`;
                    extraDiv.classList.add('visible');
                    el.appendChild(extraDiv);
                } else {
                    // --- STANDARD MODE LOGIC (Toggle + Lazy Load) ---
                    const btn = document.createElement('button');
                    btn.className = "toggle-contexts-btn";
                    btn.innerHTML = `<span class="arrow">▼</span>`;

                    let loaded = false;

                    // Toggle Logic
                    const toggleLogic = () => {
                        if (!loaded) {
                            const dC2 = formatContext(c2);
                            const dC3 = formatContext(c3);
                            extraDiv.innerHTML = `${c2 ? `<div class="context-item">${dC2}</div>` : ''}${c3 ? `<div class="context-item">${dC3}</div>` : ''}`;
                            loaded = true;
                        }
                        extraDiv.classList.toggle('visible');
                        btn.classList.toggle('active');
                    };

                    btn.onclick = toggleLogic;

                    el.appendChild(btn);
                    el.appendChild(extraDiv);

                    // Respect global state on init
                    if (globalShowAllSentences) {
                        toggleLogic(); // Immediately expand
                    }
                }
            }

            // Footer
            const footer = document.createElement('div');
            footer.className = "card-footer";
            footer.innerHTML = `<div></div><div class="actions"><button class="btn btn-ignore" onclick="ignoreWord('${safeWord}', this)">Ignore</button></div>`;
            el.appendChild(footer);

            // Sources (DOM Pruned)
            if (data.Sources) {
                const sSection = document.createElement('div');
                sSection.className = "sources-section";
                const sToggle = document.createElement('div');
                sToggle.className = "sources-toggle";
                sToggle.textContent = `Show Sources (${data.Sources.split(',').length})`;
                const sList = document.createElement('div');
                sList.className = "sources-list";
                let sLoaded = false;
                sToggle.onclick = () => {
                    if (!sLoaded) {
                        sList.textContent = data.Sources;
                        sLoaded = true;
                    }
                    if (sList.style.display === 'block') {
                        sList.style.display = 'none';
                        sToggle.textContent = sToggle.textContent.replace("Hide", "Show");
                    } else {
                        sList.style.display = 'block';
                        sToggle.textContent = sToggle.textContent.replace("Show", "Hide");
                    }
                };
                sSection.appendChild(sToggle);
                sSection.appendChild(sList);
                el.appendChild(sSection);
            }
            return el;
        }

        function toggleExtraContexts(btn) {
            const extra = btn.nextElementSibling;
            extra.classList.toggle('visible');
            btn.classList.toggle('active');
        }

        // --- Actions ---
        function toggleSources(el) {
            const list = el.nextElementSibling;

            if (list.style.display === "block") {
                list.style.display = "none";
                el.textContent = el.textContent.replace("Hide", "Show");
            }

            else {
                list.style.display = "block";
                el.textContent = el.textContent.replace("Show", "Hide");
            }
        }

        async function ignoreWord(word, btnElement) {
            try {
                // 1. Add to Local Storage
                if (!ignoredWords.has(word)) {
                    ignoredWords.add(word);
                    saveIgnoredWords();
                    updateClearButtonVisibility();
                }

                // 2. Visual Feedback: Copy to clipboard (legacy behavior)
                await navigator.clipboard.writeText(word);

                // 3. Update Button State
                const originalText = btnElement.textContent;
                btnElement.textContent = "Ignored & Copied";
                btnElement.classList.add('ignored');
                btnElement.disabled = true;

                // 4. Remove Card (Visual)
                const card = btnElement.closest('.card');
                if (card) {
                    // Fade out and remove
                    card.style.transition = 'all 0.5s ease';
                    card.style.opacity = '0';
                    card.style.transform = 'scale(0.9)';
                    setTimeout(() => {
                        card.remove();
                        // Optional: trigger a stats update here if desired, 
                        // but simple removal is usually sufficient for static view.
                    }, 500);
                }

            } catch (err) {
                console.error('Ignore failed', err);
                alert('Failed to ignore/copy: ' + word);
            }
        }

        // --- Utils ---
        function escapeHtml(text) {
            if (!text) return "";
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, " &quot; ")
                .replace(/'/g, "&#039;");

        }

        // --- Smart Navigation ---
        document.addEventListener('keydown', (e) => {
            if (e.repeat) return;

            const isNext = e.code === 'Space' || e.code === 'ArrowRight';
            const isPrev = e.code === 'ArrowLeft';
            const isUp = e.code === 'ArrowUp';
            const isDown = e.code === 'ArrowDown';

            if (!isNext && !isPrev && !isUp && !isDown) return;

            // Don't navigate if user is typing in an input/textarea
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            const isZen = typeof globalTheme !== 'undefined' && globalTheme && globalTheme.toLowerCase() === 'zen focus';

            // Prevent default scrolling/caret movement for all navigation keys
            // Exception: Allow Up/Down in Zen mode if it's NOT a custom interaction
            if (isNext || isPrev || (!isZen && (isUp || isDown))) {
                e.preventDefault();
            }

            // Selection: Standard themes have scrollable containers, Zen uses window
            let scroller = isZen ? window : document.querySelector('.view.active .word-list-container');
            if (!scroller && !isZen) return;

            const activeCards = Array.from(document.querySelectorAll('.view.active .card, body.theme-zen-focus .card'));
            if (activeCards.length === 0) return;

            const scrollerHeight = isZen ? window.innerHeight : scroller.clientHeight;
            const scrollerTop = isZen ? 0 : scroller.getBoundingClientRect().top;
            const centerLine = scrollerTop + (scrollerHeight / 2);

            let currentIndex = -1;
            let minDistance = Infinity;

            activeCards.forEach((card, index) => {
                const rect = card.getBoundingClientRect();
                const cardCenter = rect.top + (rect.height / 2);
                const distance = Math.abs(cardCenter - centerLine);

                if (distance < minDistance) {
                    minDistance = distance;
                    currentIndex = index;
                }
            });

            if (currentIndex === -1) return;

            // Handle Context Toggle (Up/Down) - only in standard mode
            if (!isZen && (isUp || isDown)) {
                const centeredCard = activeCards[currentIndex];
                const toggleBtn = centeredCard.querySelector('.toggle-contexts-btn');
                if (toggleBtn) {
                    const isShown = toggleBtn.classList.contains('active');
                    if (isDown && !isShown) {
                        toggleBtn.click();
                    } else if (isUp && isShown) {
                        toggleBtn.click();
                    }
                }
                return; // Don't perform navigation
            }

            // Handle Navigation (Next/Prev)
            if (isNext || isPrev) {
                let targetIndex = isNext ? currentIndex + 1 : currentIndex - 1;
                if (targetIndex < 0) targetIndex = 0;
                if (targetIndex >= activeCards.length) targetIndex = activeCards.length - 1;

                const targetCard = activeCards[targetIndex];
                if (targetCard) {
                    const rect = targetCard.getBoundingClientRect();
                    const cardHeight = rect.height;

                    // Target: Card center at 35% from top of scroller viewport (15% above middle)
                    const offset = (scrollerHeight * 0.35) - (cardHeight / 2);

                    if (isZen) {
                        const cardTop = rect.top + window.pageYOffset;
                        window.scrollTo({
                            top: cardTop - offset,
                            behavior: 'smooth'
                        });
                    } else {
                        const containerRect = scroller.getBoundingClientRect();
                        const currentScroll = scroller.scrollTop;
                        const cardTopRelativeToContainer = rect.top - containerRect.top;

                        scroller.scrollTo({
                            top: currentScroll + cardTopRelativeToContainer - offset,
                            behavior: 'smooth'
                        });
                    }
                }
            }
        });

    </script>
</body>

</html>